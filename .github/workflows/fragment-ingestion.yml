---
name: Fragment Ingestion Pipeline
on:
  workflow_dispatch:
    inputs:
      environment:
        description: Target environment
        required: true
        type: choice
        options: [qa, prod]
        default: qa
      batch_id:
        description: Batch ID to load (e.g., batch_20251027_115323)
        required: true
        type: string
      dry_run:
        description: Dry run mode (preview changes without loading)
        required: false
        type: boolean
        default: true
jobs:
  validate:
    name: Validate Inputs
    runs-on: ubuntu-latest
    outputs:
      batch_id: ${{ steps.validate.outputs.batch_id }}
      mode: ${{ steps.validate.outputs.mode }}
      environment: ${{ steps.validate.outputs.environment }}
    steps:
      - name: Validate batch ID format
        id: validate
        run: |
          BATCH_ID="${{ github.event.inputs.batch_id }}"
          if [[ ! "$BATCH_ID" =~ ^batch_[0-9]{8}_[0-9]{6}$ ]]; then
            echo "::error::Invalid batch_id format. Expected: batch_YYYYMMDD_HHMMSS"
            exit 1
          fi
          echo "batch_id=$BATCH_ID" >> $GITHUB_OUTPUT
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          if [[ "${{ github.event.inputs.dry_run }}" == "true" ]]; then
            echo "mode=DRY RUN" >> $GITHUB_OUTPUT
            echo "::notice::Running in DRY RUN mode - no changes will be made"
          else
            echo "mode=LIVE LOAD" >> $GITHUB_OUTPUT
            echo "::warning::Running in LIVE mode - data will be loaded to ${{ github.event.inputs.environment }} database"
          fi
  ingest:
    name: Load Fragment Data (${{ github.event.inputs.environment }})
    needs: validate
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        # Remove the 'ref' parameter - use default branch
      - name: Display environment info
        run: |
          echo "::notice::Target Environment: ${{ github.event.inputs.environment }}"
          echo "::notice::Batch ID: ${{ github.event.inputs.batch_id }}"
          echo "::notice::Mode: ${{ needs.validate.outputs.mode }}"
          echo "::notice::Branch: ${{ github.ref_name }}"
      - name: Set up SSH tunnel to database
        env:
          SSH_PRIVATE_KEY: ${{ secrets[format('SSH_PRIVATE_KEY_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          SSH_HOST: ${{ secrets[format('SSH_HOST_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          SSH_USER: ${{ secrets[format('SSH_USER_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
        run: |
          echo "::group::Setting up SSH tunnel to ${{ github.event.inputs.environment }}"
          echo "Connecting to: $SSH_HOST"
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts
          ssh -4 -f -N \
            -o ServerAliveInterval=60 \
            -o ServerAliveCountMax=3 \
            -o ExitOnForwardFailure=yes \
            -L 127.0.0.1:5432:127.0.0.1:5432 \
            $SSH_USER@$SSH_HOST
          echo "Waiting for tunnel..."
          for i in {1..30}; do
            if nc -zv 127.0.0.1 5432 2>&1 | grep -q succeeded; then
              echo "✓ SSH tunnel established successfully to ${{ github.event.inputs.environment }}"
              echo "::endgroup::"
              exit 0
            fi
            echo "Attempt $i/30..."
            sleep 2
          done
          echo "::error::Failed to establish SSH tunnel"
          echo "::endgroup::"
          exit 1
      - name: Verify database connectivity
        env:
          PGPASSWORD: ${{ secrets[format('DB_PASSWORD_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_USER: ${{ secrets[format('DB_USER_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_NAME: ${{ secrets[format('DB_NAME_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
        run: |
          echo "::group::Testing database connection to ${{ github.event.inputs.environment }}"
          sudo apt-get update -qq
          sudo apt-get install -y postgresql-client
          echo "Database: $DB_NAME"
          echo "User: $DB_USER"
          psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -c "SELECT version();"
          psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -c "SELECT current_database();"
          echo "✓ Database connection verified for ${{ github.event.inputs.environment }}"
          echo "::endgroup::"
      - name: Verify fragment_resolutions table exists
        env:
          PGPASSWORD: ${{ secrets[format('DB_PASSWORD_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_USER: ${{ secrets[format('DB_USER_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_NAME: ${{ secrets[format('DB_NAME_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
        run: |
          echo "::group::Verifying fragment_resolutions table"
          TABLE_EXISTS=$(psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -tAc \
            "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'fragment_resolutions');")
          if [ "$TABLE_EXISTS" = "t" ]; then
            echo "✓ fragment_resolutions table exists"
            # Show recent resolutions for this batch if any
            echo ""
            echo "Previous load attempts for this batch:"
            psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -c \
              "SELECT resolution_id, table_name, load_status, rows_loaded, created_at 
               FROM fragment_resolutions 
               WHERE batch_id = '${{ github.event.inputs.batch_id }}' 
               ORDER BY created_at DESC LIMIT 5;" || echo "No previous attempts found"
          else
            echo "::warning::fragment_resolutions table does not exist - tracking will be disabled"
          fi
          echo "::endgroup::"
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: pip
          cache-dependency-path: table-loader/requirements.txt
      - name: Install dependencies
        run: |
          echo "::group::Installing Python dependencies"
          cd table-loader
          pip install --upgrade pip
          pip install -r requirements.txt
          pip list | grep -E "(pandas|psycopg2|boto3)"
          echo "✓ Dependencies installed"
          echo "::endgroup::"
      - name: Create necessary directories
        run: |
          mkdir -p table-loader/logs
      - name: Verify S3 access to batch
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          S3_BUCKET: ${{ github.event.inputs.environment == 'prod' && 'idhub-curated-fragments' || 'idhub-curated-fragments-qa' }}
        run: |
          echo "::group::Verifying S3 batch exists"
          echo "Target S3 Bucket: $S3_BUCKET (environment: ${{ github.event.inputs.environment }})"
          pip install awscli
          BATCH_ID="${{ github.event.inputs.batch_id }}"
          PREFIX="staging/validated/${BATCH_ID}/"
          echo "Searching for batch at: s3://$S3_BUCKET/$PREFIX"
          echo ""
          if aws s3 ls "s3://$S3_BUCKET/$PREFIX" 2>/dev/null; then
            echo ""
            echo "✓ Found batch: $BATCH_ID in $S3_BUCKET"
            echo ""
            echo "Files in batch:"
            aws s3 ls "s3://$S3_BUCKET/$PREFIX"
            echo ""
            
            TABLE_COUNT=$(aws s3 ls "s3://$S3_BUCKET/$PREFIX" | grep '\.csv$' | grep -v 'local_subject_ids.csv' | wc -l || echo "0")
            echo "Table fragments (CSV): $TABLE_COUNT"
            
            REPORT_EXISTS=$(aws s3 ls "s3://$S3_BUCKET/$PREFIX" | grep -c 'validation_report.json' || echo "0")
            LOCAL_IDS_EXISTS=$(aws s3 ls "s3://$S3_BUCKET/$PREFIX" | grep -c 'local_subject_ids.csv' || echo "0")
            echo "Validation report: $([ "$REPORT_EXISTS" -eq "1" ] && echo "✓ Found" || echo "✗ Missing")"
            echo "Local subject IDs: $([ "$LOCAL_IDS_EXISTS" -eq "1" ] && echo "✓ Found" || echo "✗ Missing")"
            echo ""
            
            if [ "$REPORT_EXISTS" -eq "1" ]; then
              echo "Validation report preview:"
              aws s3 cp "s3://$S3_BUCKET/$PREFIX/validation_report.json" - | jq -r '.subject_id_candidates, .center_id_field, .exclude_from_load' 2>/dev/null || echo "Could not parse report"
              echo ""
            fi
            
            if [ "$TABLE_COUNT" -eq "0" ]; then
              echo "::error::No table CSV fragments found in batch"
              exit 1
            fi
            
            if [ "$REPORT_EXISTS" -eq "0" ]; then
              echo "::warning::validation_report.json not found - will use default exclusions"
            fi
          else
            echo "::error::Batch not found: $BATCH_ID in bucket $S3_BUCKET"
            echo ""
            echo "Available batches in staging/validated/:"
            aws s3 ls "s3://$S3_BUCKET/staging/validated/" || echo "Cannot list staging/validated/"
            exit 1
          fi
          echo "::endgroup::"
      - name: Run table loader (${{ needs.validate.outputs.mode }})
        id: load
        env:
          DB_HOST: localhost
          DB_NAME: ${{ secrets[format('DB_NAME_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_USER: ${{ secrets[format('DB_USER_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_PASSWORD: ${{ secrets[format('DB_PASSWORD_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_PORT: 5432
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          S3_BUCKET: ${{ github.event.inputs.environment == 'prod' && 'idhub-curated-fragments' || 'idhub-curated-fragments-qa' }}
        run: |
          echo "::group::Running table loader"
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "S3 Bucket: $S3_BUCKET"
          echo "Database: $DB_NAME"
          echo ""
          cd table-loader
          CMD="python main.py --batch-id ${{ github.event.inputs.batch_id }}"
          if [[ "${{ github.event.inputs.dry_run }}" == "false" ]]; then
            CMD="$CMD --approve"
          fi
          echo "Executing: $CMD"
          echo ""
          set +e
          $CMD 2>&1 | tee loader_output.log
          EXIT_CODE=${PIPESTATUS[0]}
          set -e
          echo ""
          if [ $EXIT_CODE -eq 0 ]; then
            echo "::notice::✓ Table loader completed successfully"
          else
            echo "::error::✗ Table loader failed with exit code $EXIT_CODE"
          fi
          echo "::endgroup::"
          exit $EXIT_CODE
      - name: Extract load summary
        if: always()
        run: |
          if [ -f table-loader/loader_output.log ]; then
            echo "::group::Load Summary"
            grep -E "(Loaded|Processing|Error|Success|Failed)" table-loader/loader_output.log || true
            RECORDS=$(grep -oP "Loaded \K\d+" table-loader/loader_output.log | tail -1 || echo "0")
            echo "Records processed: $RECORDS"
            echo "::endgroup::"
          fi
      - name: Query fragment resolutions
        if: always()
        env:
          PGPASSWORD: ${{ secrets[format('DB_PASSWORD_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_USER: ${{ secrets[format('DB_USER_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_NAME: ${{ secrets[format('DB_NAME_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
        run: |
          echo "::group::Fragment Resolution Summary"

          # Check if table exists
          TABLE_EXISTS=$(psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -tAc \
            "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'fragment_resolutions');")
          if [ "$TABLE_EXISTS" = "t" ]; then
            echo "=== Load Statistics for Batch: ${{ github.event.inputs.batch_id }} ==="
            echo ""
            
            # Overall statistics
            psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -c \
              "SELECT 
                COUNT(*) as total_fragments,
                SUM(rows_loaded) as total_rows_loaded,
                SUM(rows_failed) as total_rows_failed,
                COUNT(*) FILTER (WHERE load_status = 'success') as successful,
                COUNT(*) FILTER (WHERE load_status = 'failed') as failed,
                COUNT(*) FILTER (WHERE requires_review = TRUE) as needs_review,
                ROUND(AVG(execution_time_ms)::numeric, 2) as avg_time_ms
               FROM fragment_resolutions 
               WHERE batch_id = '${{ github.event.inputs.batch_id }}';"
            
            echo ""
            echo "=== Per-Table Results ==="
            psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -c \
              "SELECT 
                table_name,
                load_status,
                load_strategy,
                rows_loaded,
                rows_failed,
                execution_time_ms,
                requires_review,
                CASE WHEN requires_review THEN review_reason ELSE '' END as review_reason
               FROM fragment_resolutions 
               WHERE batch_id = '${{ github.event.inputs.batch_id }}'
               ORDER BY created_at;"
            
            echo ""
            echo "=== Items Requiring Review ==="
            REVIEW_COUNT=$(psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -tAc \
              "SELECT COUNT(*) FROM fragment_resolutions 
               WHERE batch_id = '${{ github.event.inputs.batch_id }}' 
               AND requires_review = TRUE;")
            
            if [ "$REVIEW_COUNT" -gt "0" ]; then
              echo "::warning::$REVIEW_COUNT fragment(s) require manual review"
              psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -c \
                "SELECT resolution_id, table_name, review_reason, error_message 
                 FROM fragment_resolutions 
                 WHERE batch_id = '${{ github.event.inputs.batch_id }}' 
                 AND requires_review = TRUE;"
            else
              echo "✓ No fragments require review"
            fi
          else
            echo "::warning::fragment_resolutions table not found - skipping resolution summary"
          fi
          echo "::endgroup::"
      - name: Export resolution report
        if: always() && github.event.inputs.dry_run == 'false'
        env:
          PGPASSWORD: ${{ secrets[format('DB_PASSWORD_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_USER: ${{ secrets[format('DB_USER_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_NAME: ${{ secrets[format('DB_NAME_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
        run: |
          echo "::group::Exporting resolution report"
          TABLE_EXISTS=$(psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -tAc \
            "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'fragment_resolutions');")
          if [ "$TABLE_EXISTS" = "t" ]; then
            mkdir -p table-loader/reports
            psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -c \
              "COPY (
                SELECT 
                  resolution_id,
                  batch_id,
                  table_name,
                  load_status,
                  load_strategy,
                  rows_attempted,
                  rows_loaded,
                  rows_failed,
                  execution_time_ms,
                  requires_review,
                  review_reason,
                  error_message,
                  created_at
                FROM fragment_resolutions 
                WHERE batch_id = '${{ github.event.inputs.batch_id }}'
                ORDER BY created_at
              ) TO STDOUT WITH CSV HEADER" > table-loader/reports/fragment_resolutions_${{ github.event.inputs.batch_id }}.csv
            echo "✓ Resolution report exported"
          fi
          echo "::endgroup::"
      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: loader-logs-${{ github.event.inputs.environment }}-${{ github.event.inputs.batch_id
            }}
          path: |
            table-loader/logs/
            table-loader/loader_output.log
            table-loader/reports/
          retention-days: 30
          if-no-files-found: warn
      - name: Upload load report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: load-report-${{ github.event.inputs.environment }}-${{ github.event.inputs.batch_id
            }}
          path: |
            table-loader/loader_output.log
            table-loader/reports/fragment_resolutions_*.csv
          retention-days: 90
          if-no-files-found: warn
      - name: Cleanup SSH tunnel
        if: always()
        run: |
          pkill -f "ssh.*127.0.0.1:5432" || true
          echo "✓ SSH tunnel closed"
      - name: Notify on failure
        if: failure() && github.event.inputs.dry_run == 'false'
        run: |
          echo "::error::Fragment ingestion failed for batch ${{ github.event.inputs.batch_id }} in ${{ github.event.inputs.environment }}"
          echo "Check the uploaded logs for details"
      - name: Summary
        if: always()
        env:
          PGPASSWORD: ${{ secrets[format('DB_PASSWORD_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_USER: ${{ secrets[format('DB_USER_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
          DB_NAME: ${{ secrets[format('DB_NAME_{0}', github.event.inputs.environment == 'prod' && 'PROD' || 'QA')] }}
        run: |-
          echo "## Fragment Ingestion Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Batch ID**: \`${{ github.event.inputs.batch_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Mode**: ${{ needs.validate.outputs.mode }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by**: @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Add resolution statistics if available
          TABLE_EXISTS=$(psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -tAc \
            "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'fragment_resolutions');" || echo "f")
          if [ "$TABLE_EXISTS" = "t" ]; then
            echo "### Load Statistics" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            STATS=$(psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -tAc \
              "SELECT 
                COALESCE(SUM(rows_loaded), 0) || '|' || 
                COALESCE(SUM(rows_failed), 0) || '|' || 
                COALESCE(COUNT(*) FILTER (WHERE load_status = 'success'), 0) || '|' ||
                COALESCE(COUNT(*) FILTER (WHERE requires_review = TRUE), 0)
               FROM fragment_resolutions 
               WHERE batch_id = '${{ github.event.inputs.batch_id }}';" || echo "0|0|0|0")
            
            IFS='|' read -r ROWS_LOADED ROWS_FAILED SUCCESS_COUNT REVIEW_COUNT <<< "$STATS"
            
            echo "- **Rows Loaded**: $ROWS_LOADED" >> $GITHUB_STEP_SUMMARY
            echo "- **Rows Failed**: $ROWS_FAILED" >> $GITHUB_STEP_SUMMARY
            echo "- **Successful Tables**: $SUCCESS_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "- **Requires Review**: $REVIEW_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [ "$REVIEW_COUNT" -gt "0" ]; then
              echo "### ⚠️ Items Requiring Review" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              psql -h localhost -p 5432 -U $DB_USER -d $DB_NAME -tA \
                "SELECT table_name || ': ' || review_reason 
                 FROM fragment_resolutions 
                 WHERE batch_id = '${{ github.event.inputs.batch_id }}' 
                 AND requires_review = TRUE;" >> $GITHUB_STEP_SUMMARY || true
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          if [ -f table-loader/loader_output.log ]; then
            echo "### Load Details" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            tail -20 table-loader/loader_output.log >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
